# Agent Edge - Multi-Site Edge Intelligence Demo

## Project Overview
Distributed AI agent system: two autonomous agents (Jetson Orin Nano + Mac Mini M2) coordinate via Google ADK + A2A protocol. The Jetson reads an ENS160+AHT21 sensor module (temperature, humidity, eCO2, TVOC, AQI) through an Arduino via MCP protocol. Both agents run Liquid AI LFM2.5-1.2B-Thinking locally via Ollama + LiteLLM. Dashboard via Streamlit.

## Architecture
```
[Arduino ENS160+AHT21] → USB Serial → [MCP Server] → [Sensor Loop]
                                                          ↓
Dashboard → A2A message/send → [Mac Mini ADK Agent] ← REST push ← [Jetson ADK Agent]
                                    ↑                                    ↑
                              REST /api/*                          /.well-known/agent-card.json
```

**Key flow:**
- **Chat**: Dashboard → A2A `message/send` (JSON-RPC) → Mac Mini → (delegates via sub_agents) → Jetson
- **Data**: Sensor loop → REST push → Mac Mini → REST `/api/*` → Dashboard
- **Agent cards**: Auto-served at `/.well-known/agent-card.json` by `to_a2a()`

## Key Tech
- **Python 3.10+**, FastAPI, WebSocket, asyncio
- **Agent framework**: Google ADK (`google-adk[a2a]`), `a2a-sdk`
- **LLM**: LiquidAI/LFM2.5-1.2B-Thinking via Ollama + LiteLLM (`ollama_chat/lfm2.5-thinking`)
- **Sensor**: ENS160 (eCO2, TVOC, AQI) + AHT21 (temp, humidity) over I2C
- **Arduino**: ScioSense_ENS160 + Adafruit_AHTX0 libraries, JSON over serial at 9600 baud
- **Protocols**: MCP (agent-to-system), A2A (agent-to-agent via ADK)
- **Storage**: JSON Lines files (no database)
- **Dashboard**: Streamlit + Plotly

## Sensor JSON Schema (flows through all layers)
```json
{"temp": 24.5, "humidity": 65.2, "eco2": 450, "tvoc": 120, "aqi": 1}
```
- `eco2`: ppm (parts per million) — threshold: >1000 = poor air
- `tvoc`: ppb (parts per billion) — threshold: >500 = elevated VOCs
- `aqi`: 1-5 scale (ENS160 index) — threshold: >=4 = unhealthy
- `temp` delta: >5C from previous = anomaly

## Project Structure
```
arduino/sensor_reader/              # Arduino .ino for ENS160+AHT21
mcp_servers/arduino/                # MCP server exposing read_sensor tool
shared/
  state.py                          # Module-level shared state (per-process)
  storage.py                        # JSON Lines storage utilities
agents/jetson/
  agent_def.py                      # ADK LlmAgent definition + tools
  server.py                         # Hybrid server: to_a2a() + FastAPI routes
  sensor_loop.py                    # Background task: MCP read → push to Mac Mini
  tools.py                          # Tool functions: detect_anomalies, get_latest_reading
  dashboard_routes.py               # REST APIRouter for /api/sensor/current
  mcp_client.py                     # MCP client for Arduino serial
  config.py                         # Environment-based configuration
agents/macmini/
  agent_def.py                      # ADK LlmAgent + RemoteA2aAgent(jetson)
  server.py                         # Hybrid server: to_a2a() + FastAPI routes
  tools.py                          # Tool functions: compute_statistics, get_history
  dashboard_routes.py               # REST APIRouter for /api/history, /api/chat, etc.
  config.py                         # Environment-based configuration
dashboard/
  app.py                            # Streamlit main — data via REST, chat via A2A
  a2a_client.py                     # Sync A2A JSON-RPC client for Streamlit
  components/                       # UI components (chat, agent status, charts, etc.)
scripts/                            # Setup and demo launcher scripts
tests/                              # pytest suite
```

## Hybrid Server Pattern
Each agent server combines:
1. **A2A endpoints** — auto-generated by `to_a2a(root_agent)`, mounted at `/`
2. **Custom REST routes** — FastAPI `APIRouter` mounted at `/api/*`
3. **WebSocket** — `/stream` for real-time dashboard updates
4. **Background tasks** — sensor loop (Jetson), historical data loading (Mac Mini)

```python
app = FastAPI(lifespan=lifespan)
app.include_router(dashboard_router, prefix="/api")
app.mount("/", to_a2a(root_agent, port=PORT))  # catch-all for A2A
```

## Development Guidelines
- This is a **live demo** for AI Futures Lab — reliability > features
- Keep it simple: two agents, one sensor module, clear collaboration story
- All network calls: retry with exponential backoff (max 3 attempts)
- Use Python `logging` module, JSON Lines format for logs
- ENS160 needs ~1 min warm-up; handle gracefully
- Environment variables for IPs/ports, config files for thresholds
- **Serial port is exclusive** — only the sensor loop owns the MCP connection; ADK tools return cached readings

## Anomaly Detection (Jetson Agent)
Any of these triggers LFM analysis:
1. Temperature delta > 5C
2. eCO2 > 1000 ppm
3. TVOC > 500 ppb
4. AQI >= 4

## Testing
- Run tests with: `python3 -m pytest tests/ -v`
- Unit tests for tool functions and A2A client
- Integration tests for REST dashboard routes
- End-to-end: sensor → collaboration → dashboard

## Ports
- Jetson agent: 8080 (A2A + REST + WebSocket)
- Mac Mini agent: 8081 (A2A + REST + WebSocket)
- Arduino serial: /dev/ttyUSB0 (Jetson), configurable

## Environment Variables
- `OLLAMA_API_BASE=http://localhost:11434` — required for LiteLLM/Ollama
- `JETSON_AGENT_URL=http://localhost:8080`
- `MACMINI_AGENT_URL=http://localhost:8081`
- `SERIAL_PORT=/dev/ttyUSB0`

## Dashboard
Use the **frontend-design** skill when building dashboard components for distinctive, polished UI. The dashboard should be visually compelling for a technical audience demo.
